<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Quantum Computing, getting started">

<title>Quantum Computing, getting started</title>

<!-- Bootstrap style: bootstrap -->
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}

/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Introduction', 1, None, '___sec0'),
              ('Hamiltonians', 2, None, '___sec1'),
              ('Basic quantum  gates', 2, None, '___sec2'),
              ('Qubits, gates and circuits', 3, None, '___sec3'),
              ('Number of work qubits versus number of simulation qubits',
               2,
               None,
               '___sec4'),
              ('Number of operations', 2, None, '___sec5')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="quantumcomputing-bs.html">Quantum Computing, getting started</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#___sec0" style="font-size: 80%;"><b>Introduction</b></a></li>
     <!-- navigation toc: --> <li><a href="#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Hamiltonians</a></li>
     <!-- navigation toc: --> <li><a href="#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Basic quantum  gates</a></li>
     <!-- navigation toc: --> <li><a href="#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Qubits, gates and circuits</a></li>
     <!-- navigation toc: --> <li><a href="#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Number of work qubits versus number of simulation qubits</a></li>
     <!-- navigation toc: --> <li><a href="#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Number of operations</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0000"></a>
<!-- ------------------- main content ---------------------- -->



<div class="jumbotron">
<center><h1>Quantum Computing, getting started</h1></center>  <!-- document title -->

<p>
<!-- author(s): Morten Hjorth-Jensen -->

<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Department of Physics, University of Oslo</b></center>
<center>[2] <b>Department of Physics and Astronomy and National Superconducting Cyclotron Laboratory, Michigan State University</b></center>
<br>
<p>
<center><h4>May 17, 2018</h4></center> <!-- date -->
<br>
<p>
</div> <!-- end jumbotron -->

<h1 id="___sec0" class="anchor">Introduction </h1>

<p>
A theoretical understanding of the behavior of many-body systems is a
great challenge and provides fundamental insights into quantum
mechanical studies, as well as offering potential areas of
applications.  However, apart from some few analytically solvable
problems, the typical absence of an exactly solvable contribution to
the many-particle Hamiltonian means that we need reliable numerical
many-body methods.  These methods should allow for controlled
approximations and provide a computational scheme which accounts for
successive many-body corrections in a systematic way.  Typical
examples of popular many-body methods are coupled cluster methods,
various types of Monte Carlo methods, perturbative expansions, Green's
function methods, the density-matrix renormalization group, ab initio
density functional theory and large-scale diagonalization methods.

<p>
All these methods have to face in some form or the other the problem
of an exponential growth in dimensionality. For a system of \( P \)
fermions which can be placed into \( N \) levels, the total number of
basis states are given by
\( \left(\begin{array}{c}N\\P\end{array}\right) \).  The dimensional curse
means that most quantum mechanical calculations on classical computers
have exponential complexity and therefore are very hard to solve for
larger systems. On the other hand, a so-called quantum computer, a
particularly dedicated computer, can improve greatly on the size of
systems that can be simulated, as foreseen by Feynman. A quantum computer does not need an
exponential amount of memory to represent a quantum state.  The basic
unit of information for a quantum computer is the so-called qubit or
quantum bit. Any suitable two-level quantum system can be a qubit, but
the standard model of quantum computation is a model where two-level
quantum systems are located at different points in space, and are
manipulated by a small universal set of operations.  These operations
are called gates in the same fashion as operations on bits in
classical computers are called gates.

<p>
For the example of \( P \) spin \( 1/2 \) particles, a classical computer
needs \( 2^P \) bits to represent all possible states, while a quantum
computer needs only \( P \) qubits. The complexity in number of qubits is
thus linear.  Based on these ideas, several groups have proposed
various algorithms for simulating quantal many-body systems on quantum
computers.  Abrams and Lloyd introduced a quantum algorithm that uses
the quantum fast Fourier transform to find eigenvalues and
eigenvectors of a given Hamiltonian, illustrating how one could solve
classically intractable problems with less than 100 qubits.  Achieving
a polynomial complexity in the number of operations needed to simulate
a quantum system is not that straightforward however.  To get
efficient simulations in time one needs to transform the many-body
Hamiltonian into a sum of operations on qubits, the building blocks of
the quantum simulator and computer, so that the time evolution
operator can be implemented in polynomial time.

<p>
The aim of this work is to develop an algorithm than allows one to
perform a quantum computer simulation (or simply quantum simulation
hereafter) of any many-body fermionic Hamiltonian. We show how to
generate, via various Jordan-Wigner transformations, all qubit
operations needed to simulate the time evolution operator of a given
Hamiltonian.  We also show that for a given term in an \( m \)-body
fermionic Hamiltonian, the number of operations needed to simulate it
is linear in the number of qubits or energy-levels of the system. The
number of terms in the Hamiltonian is of the order of \( m^2 \) for a
general \( m \)-body interaction, making the simulation increasingly
harder with higher order interactions. We specialize our examples to a
two-body Hamiltonian, since this is also the most general type of
Hamiltonian encountered in many-body physics.  Besides fields like
nuclear physics, where three-body forces play a non-neglible role, a
two-body Hamiltonian captures most of the relevant physics.

<h2 id="___sec1" class="anchor">Hamiltonians </h2>

<p>
A general two-body Hamiltonian for fermionic system 
can be written as

$$
\begin{equation}
\tag{1}
H = E_0 + \sum_{ij=1} E_{ij} a^\dag_i a_j
+\sum_{ijkl = 1} V_{ijkl} a^\dag_i a^\dag_j a_l a_k,
\end{equation}
$$

where \( E_0 \) is a constant energy term, \( E_{ij} \) represent all the
one-particle terms, allowing for non-diagonal terms as well. The
one-body term can represent 
a chosen single-particle potential, the kinetic energy or other more
specialized terms such as  
those discussed in connection with the Hubbard model or the pairing Hamiltonian  
discussed below.
The two-body interaction part is given by \( V_{ijkl} \) and can be any
two-body interaction, from 
Coulomb interaction to the interaction between nucleons.  
The sums run over all possible single-particle levels \( N \). 
Note that
this model includes particle numbers from zero to the number of
available quantum levels, \( n \). To simulate states with fixed numbers
of fermions one would have to either rewrite the Hamiltonian or
generate specialized input states in the simulation.

<p>
The algorithm which we will develop in this section and in
However, 
in our demonstrations of the quantum computing algorithm, we will limit ourselves to
two simple models, which however capture much of the important physics
in quantum mechanical 
many-body systems. We will also limit ourselves to spin \( j=1/2 \)
systems, although our algorithm 
can also simulate  higher \( j \)-values, such as those which occur in nuclear, atomic and
molecular physics, it simply uses one qubit for every available
quantum state.   
These simple models are the Hubbard model and a pairing
Hamiltonian.
We start with the spin \( 1/2 \) Hubbard model, described by the following Hamiltonian

$$
\begin{align}
H_H &&= \epsilon \sum_{i, \sigma} a_{i\sigma}^\dag a_{i\sigma} 
-t \sum_{i, \sigma} \left(a^\dag_{i+1, \sigma}a_{i, \sigma}
+a^\dag_{i, \sigma}a_{i+1, \sigma} \right) \notag 
\tag{2}\\
&& + U \sum_{i=1} a_{i+}^\dag a_{i-}^\dag a_{i-}a_{i+},
\tag{3}
\end{align}
$$

where \( a^{\dagger} \) and \( a \) are fermion creation and annihilation operators, respectively.
This is a chain of sites where each site has room for one spin up
fermion and one spin down fermion. 
The number of sites is \( N \), and the sums over \( \sigma \) are sums over
spin up and down only.
Each site has a single-particle
energy \( \epsilon \). There is a repulsive term \( U \) if there is a pair
of particles at the same site. It is energetically favourable to tunnel to
neighbouring sites, described by 
the hopping terms with coupling constant \( -t \).

<p>
The second model-Hamiltonian is the simple pairing Hamiltonian
$$
\begin{equation}
   H_P=\sum_i \varepsilon_i a^{\dagger}_i a_i -\frac{1}{2} g\sum_{ij>0}
           a^{\dagger}_{i}
     a^{\dagger}_{\bar{\imath}}a_{\bar{\jmath}}a_{j},
\tag{4}
\end{equation}
$$

 The indices \( i \) and \( j \) run over the number of levels \( N \), and the label \( \bar{\imath} \) 
stands for a time-reversed state. The parameter \( g \) is the strength of the pairing force 
while \( \varepsilon_i \) is the single-particle energy of level \( i \). 
In our case
we assume that the single-particle levels are equidistant (or
degenerate) with a fixed spacing \( d \). 
Moreover, in our simple model, the degeneracy of the single-particle
levels is set to \( 2j+1=2 \), with \( j=1/2 \)  
being the spin of the particle. This gives a set of single-particle
states with the same spin projections as 
for the Hubbard model.  Whereas in the Hubbard model we operate with
different sites with  
spin up or spin down particles, our pairing models deals thus with
levels  with double degeneracy. 
Introducing the pair-creation operator 
\( S^+_i=a^{\dagger}_{im}a^{\dagger}_{i-m} \),
one can rewrite the Hamiltonian in 
Eq.&nbsp;<a href="#mjx-eqn-4">(4)</a> as

$$
\begin{equation*}
   H_P=d\sum_iiN_i+
     \frac{1}{2} G\sum_{ij>0}S^+_iS^-_j,
\end{equation*}
$$

where  \( N_i=a^{\dagger}_i a_i \)
is the number operator, and 
\( \varepsilon_i = id \) so that the single-particle orbitals 
are equally spaced at intervals \( d \). The latter commutes with the 
Hamiltonian \( H \). In this model, quantum numbers like seniority 
\( \cal{S} \) are good quantum numbers, and the eigenvalue problem 
can be rewritten in terms of blocks with good seniority. 
Loosely 
speaking, the seniority quantum number \( \cal{S} \) is equal to 
the number of unpaired particles.
Furthermore, in  a series of papers, Richardson
obtained the exact solution of the pairing Hamiltonian, with 
semi-analytic (since there is still the need for a numerical solution) 
expressions for the eigenvalues and eigenvectors. The exact solutions
have had important consequences for several fields, from Bose condensates to
nuclear superconductivity and is currently a very active field of studies, see for example
Finally, for particle numbers up to \( P \sim 20 \), the above model can be 
solved exactly through numerical diagonalization and one can obtain all eigenvalues.
It serves therefore also as an excellent ground for comparison with our algorithm based
on models from quantum computing.

<h2 id="___sec2" class="anchor">Basic quantum  gates </h2>

<p>
Benioff showed that one could make a quantum mechanical Turing machine
by using various  unitary operations on a quantum system.
Benioff  demonstrated 
that a quantum computer can calculate anything a
classical computer can. To do this one needs a quantum system and
basic operations that can approximate all unitary operations
on the chosen many-body system. We describe in this subsection the basic ingredients entering 
our algorithms.

<h3 id="___sec3" class="anchor">Qubits, gates and circuits </h3>

In this article we will use the standard model of quantum information,
where
the basic unit of information is the qubit, the quantum bit. 
As mentioned in the introduction, any
suitable 
two-level quantum system can be a qubit, 
it is the smallest system there is with the
least complex dynamics.
Qubits are both abstract measures of information and physical objects.
Actual physical qubits can be ions trapped in magnetic fields where
lasers can access only two energy levels or  the nuclear spins of some of
the atoms in molecules accessed and manipulated by an NMR machine.
Several other ideas have been proposed and some tested.

<p>
The computational basis for one qubit is \( {\ensuremath{|0\rangle}} \) (representing for example bit \( 0 \)) 
for the first state
and \( {\ensuremath{|1\rangle}} \) (representing bit \( 1 \)) for the second, and for a set of qubits  
the tensor products of
these basis states for each qubit form a product basis. Below we write out the different
basis states for a system of \( n \) qubits.

$$
\begin{align}
\tag{5}
&{\ensuremath{|0\rangle}} \equiv {\ensuremath{|00\cdots 0\rangle}} =
      {\ensuremath{|0\rangle}} \otimes {\ensuremath{| 0\rangle}} \otimes
          \cdots 
\otimes {\ensuremath{|0\rangle}} 
\notag \\
&{\ensuremath{|1\rangle}} \equiv {\ensuremath{|00\cdots 1\rangle}} =
    {\ensuremath{|0\rangle}} \otimes {\ensuremath{| 0\rangle}} \otimes
        \cdots 
\otimes {\ensuremath{|1\rangle}} 
\notag 
\tag{6}\\
&\vdots \notag 
\tag{7}\\
&{\ensuremath{|2^n-1\rangle}} \equiv {\ensuremath{|11\cdots 1\rangle}} =
    {\ensuremath{|1\rangle}} \otimes {\ensuremath{| 1\rangle}} \otimes 
\cdots \otimes {\ensuremath{|1 \rangle}}.
\notag 
\tag{8}\\
\tag{9}
\end{align}
$$

This is a \( 2^n \)-dimensional system and we number the different basis
states using binary numbers corresponding to the order in which they appear in the
tensor product.

<p>
Quantum computing means to  manipulate and measure  qubits in such a
way that the results from a measurement yield the solutions to  a given problem. 
The quantum operations we need to be able to perform our simulations are 
a small set of elementary single-qubit
operations, or single-qubit gates, and one universal two-qubit gate,
in our case the so-called CNOT gate defined below.

<p>
To represent quantum computer algorithms graphically we use circuit
diagrams. In a circuit diagram each qubit is represented by a line,
and operations on the different qubits are represented by boxes.

<h2 id="___sec4" class="anchor">Number of work qubits versus number of simulation qubits </h2>

<p>
The largest possible amount of different eigenvalues is \( 2^s \), where
\( s \) is the number of simulation qubits. The resolution in the energy
spectrum we get from measuring upon the work qubits is \( 2^w \), with \( w \) the number of
work qubits.
Therefore the resolution per eigenvalue in a non-degenerate system is
\( 2^{w-s} \). The higher the degeneracy the less work qubits are needed.

<h2 id="___sec5" class="anchor">Number of operations </h2>

<p>
Counting the number of single-qubit and \( \sigma_z\sigma_z \) operations
for different sizes of systems simulated gives us an indication of the
decoherence time needed for different physical realizations of a
quantum simulator or computer. The decoherence time is an average time
in which the state of the qubits will be destroyed by noise, also called 
decoherence, while the operation time is the average time an operation takes
to perform on the given system. Their fraction is the number of
operations possible to perform before decoherence destroys the
computation. In table  we have listed the number of
gates used for the pairing model, \( H_P \), and the Hubbard model, \( H_H \),
for different number of simulation qubits.

<p>

<div class="row">
  <div class="col-xs-7">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center"><b>         </b></td> <td align="center">\( s=2 \)</td> <td align="center">\( s=4 \)</td> <td align="center">\( s=6 \)</td> <td align="center">\( s=8 \)</td> <td align="center">\( s=10 \)</td> <td align="center">\( s=12 \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   \( H_P \)    </td> <td align="center">   9            </td> <td align="center">   119          </td> <td align="center">   333          </td> <td align="center">   651          </td> <td align="center">   1073          </td> <td align="center">   1598          </td> </tr>
<tr><td align="left">   \( H_H \)    </td> <td align="center">   9            </td> <td align="center">   51           </td> <td align="center">   93           </td> <td align="center">   135          </td> <td align="center">   177           </td> <td align="center">   219           </td> </tr>
</tbody>
    </table>
  </div> <!-- col-xs-7 -->
</div> <!-- cell row -->
<p>
Number of two-qubit gates used in simulating the time
  evolution operator of the pairing model, \( H_P \), and the Hubbard
  model, \( H_H \), for different number of simulation qubits \( s \).

<p>
We list here some useful relations involving different \( \sigma \) matrices,

$$
\begin{equation}
\sigma_x \sigma_z = -i\sigma_y, \quad
\sigma_z \sigma_x = i\sigma_y, \quad [\sigma_x, \sigma_z]=-2i\sigma_y,
\tag{10}
\end{equation}
$$


$$
\begin{equation}
\sigma_x \sigma_y = i\sigma_z, \quad
\sigma_y \sigma_x = -i\sigma_z, \quad [\sigma_x, \sigma_y]=2i\sigma_z,
\tag{11}
\end{equation}
$$

and

$$
\begin{equation}
\sigma_y \sigma_z = i\sigma_x, \quad
\sigma_z \sigma_y = -i\sigma_x, \quad [\sigma_y, \sigma_z]=2i\sigma_x.
\tag{12}
\end{equation}
$$

<p>
For any two non-equal \( \sigma \)-matrices \( a \) and \( b \) we have

$$
\begin{equation}
aba = -b.
\tag{13}
\end{equation}
$$

<p>
The Hermitian \( \sigma \)-matrices \( \sigma_x \), \( \sigma_y \) and \( \sigma_z \)
result in the identity matrix when squared

$$
\begin{equation}
\sigma_x^2 = _1_,\quad 
\sigma_y^2 = _1_,\quad 
\sigma_z^2 = _1_,\quad 
\tag{14}
\end{equation}
$$

which can be used to obtain  simplified expressions for exponential functions involving \( \sigma \)-matrices

$$
\begin{equation}
e^{\pm i\alpha \sigma}=\cos(\alpha) _1_ \pm i \sin(\alpha) \sigma. 
\tag{15}
\end{equation}
$$

<p>
The equations we list below are necessary for the relation between  a general unitary
transformation on a set of qubits with  a product of two-qubit unitary
transformations. We have the general equation for \( a,b \in \{\sigma_x,\sigma_y, \sigma_z\} \), where \( a\neq b \).

$$
\begin{align}
  e^{-i\pi/4a} b e^{i\pi/4a} &&= \frac{1}{2} (_1_ -ia) b ( _1_ + ia)
  \notag
\tag{16}\\ 
  &&=  \frac{1}{2} (b + aba + i[b,a]) \notag
\tag{17}\\
  &&= \frac{i}{2}[b,a].
\tag{18}
\end{align}
$$

<p>
The more specialized equations read
$$
\begin{align}
\tag{19}
  &&e^{-i\pi/4 \sigma_x} \sigma_z e^{i\pi/4 \sigma_x} = -\sigma_y, \\
\tag{20}
  &&e^{-i\pi/4 \sigma_y} \sigma_z e^{i\pi/4 \sigma_y} = \sigma_x, \\
\tag{21}
  &&e^{-i\pi/4 \sigma_z} \sigma_x e^{i\pi/4 \sigma_z} = \sigma_y, \\
\tag{22}
  &&e^{-i\pi/4 \sigma_z} \sigma_y e^{i\pi/4 \sigma_z} = -\sigma_x. 
\end{align}
$$

<p>
We need also different products of the operator$\sigma_z$  with the  raising and lowering operators

$$
\begin{align}
\tag{23}
  &&\sigma_+ \sigma_z = -\sigma_+ \\
  &&\sigma_z \sigma_+ = \sigma_+, 
\tag{24}\\
  &&\sigma_- \sigma_z = \sigma_-, 
\tag{25}\\
  &&\sigma_z \sigma_- = -\sigma_-. 
\tag{26}\\
\tag{27}
\end{align}
$$


<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pagination">
  <li class="active"><a href="._quantumcomputing-bs000.html">1</a></li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2018, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>


</body>
</html>
    

